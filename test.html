<!DOCTYPE html>
<html>
<head>
    <title>Calculadora de Centroide y momento de inercia</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: Arial, sans-serif;
            background-image: url('fondo.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh; /* 100% del viewport height */
            margin: 0;
        }
        
        canvas {
            border: 1px solid black;
            background-color: white;
            width: 80vw; /* 80% del viewport width */
            max-width: 800px; /* Máximo ancho para evitar que se haga demasiado grande */
            height: auto; /* Se ajusta automáticamente según el ancho especificado */
            max-height: 600px; /* Máximo alto para evitar que se haga demasiado alto */
        }
        

        #labelIsHollow {
            color: #ff6347; /* Naranja */
        }

        h1 {
            color: white;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>Calculadora de Centroide y momento de inercia</h1>
    <canvas id="canvas" width="800" height="600"></canvas>
    <br>
    <div>
        <input type="checkbox" id="isHollow" checked>
        <label for="isHollow" id="labelIsHollow">Forma Hueca</label>
        <button onclick="iniciarLinea()">Dibujar Línea</button>
        <button onclick="prepararSemicirculo()">Dibujar Semicírculo</button>
        <button onclick="prepararCuartoCirculo()">Dibujar 1/4 de Círculo</button>
        <button onclick="prepararCirculo()">Dibujar Círculo</button>
        <button onclick="prepararRectangulo()">Dibujar Rectángulo</button>
        <button onclick="prepararCuadrado()">Dibujar Cuadrado</button>
        <button onclick="exportToJPG()">Exportar a JPG</button>
        <button onclick="limpiarLienzo()">Limpiar Lienzo</button>
        <button onclick="undo()">Deshacer</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        let isDrawing = false;
        let startX, startY;
        let lines = [];
        let shapes = [];
        let drawingMode = null;
        let radius = 0;
        let direction = '';
        let isHollow = true;

        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            redrawCanvas();
        }
        
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawShapes(ctx);
            drawLines(ctx);
        }
        
        // Escuchar cambios en el tamaño de la ventana
        window.addEventListener('resize', resizeCanvas);
        
        // Llamar a resizeCanvas al cargar la página para ajustar inicialmente el tamaño
        window.addEventListener('load', resizeCanvas);

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);

        document.getElementById('isHollow').addEventListener('change', function() {
            isHollow = this.checked;
        });

        function startDrawing(e) {
            isDrawing = true;
            startX = e.offsetX;
            startY = e.offsetY;
        }

        function draw(e) {
            if (!isDrawing) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawShapes(ctx);
            drawLines(ctx);
            ctx.beginPath();
            if (drawingMode === 'line') {
                ctx.moveTo(startX, startY);
                ctx.lineTo(e.offsetX, e.offsetY);
            } else if (drawingMode === 'semicircle' || drawingMode === 'quartercircle') {
                let endX = e.offsetX;
                let endY = e.offsetY;
                radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                if (drawingMode === 'semicircle') {
                    drawSemiCirclePreview(ctx, startX, startY, radius, direction);
                } else if (drawingMode === 'quartercircle') {
                    drawQuarterCirclePreview(ctx, startX, startY, radius, direction);
                }
            } else if (drawingMode === 'circle') {
                let endX = e.offsetX;
                let endY = e.offsetY;
                radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                ctx.arc(startX, startY, radius, 0, 2 * Math.PI);
            } else if (drawingMode === 'rectangle') {
                let endX = e.offsetX;
                let endY = e.offsetY;
                let width = endX - startX;
                let height = endY - startY;
                ctx.rect(startX, startY, width, height);
            } else if (drawingMode === 'square') {
                let endX = e.offsetX;
                let endY = e.offsetY;
                let sideLength = Math.max(Math.abs(endX - startX), Math.abs(endY - startY));
                ctx.rect(startX, startY, sideLength, sideLength);
            }
            ctx.stroke();
        }

        function stopDrawing(e) {
            isDrawing = false;
            const endX = e.offsetX;
            const endY = e.offsetY;
            if (drawingMode === 'line') {
                lines.push({ start: { x: startX, y: startY }, end: { x: endX, y: endY } });
            } else if (drawingMode === 'semicircle') {
                shapes.push({ type: 'semicircle', x: startX, y: startY, radius: radius, direction: direction, isHollow: isHollow });
            } else if (drawingMode === 'quartercircle') {
                shapes.push({ type: 'quartercircle', x: startX, y: startY, radius: radius, direction: direction, isHollow: isHollow });
            } else if (drawingMode === 'circle') {
                shapes.push({ type: 'circle', x: startX, y: startY, radius: radius, isHollow: isHollow });
            } else if (drawingMode === 'rectangle') {
                let width = endX - startX;
                let height = endY - startY;
                shapes.push({ type: 'rectangle', x: startX, y: startY, width: width, height: height, isHollow: isHollow });
            } else if (drawingMode === 'square') {
                let sideLength = Math.max(Math.abs(endX - startX), Math.abs(endY - startY));
                shapes.push({ type: 'square', x: startX, y: startY, sideLength: sideLength, isHollow: isHollow });
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawShapes(ctx);
            drawLines(ctx);
        }

        function drawLines(ctx) {
            ctx.beginPath();
            lines.forEach(line => {
                ctx.moveTo(line.start.x, line.start.y);
                ctx.lineTo(line.end.x, line.end.y);
            });
            ctx.stroke();
        }
        
        function drawShapes(ctx) {
            shapes.forEach(shape => {
                ctx.beginPath();
                if (shape.type === 'semicircle') {
                    drawSemiCircle(ctx, shape.x, shape.y, shape.radius, shape.direction);
                } else if (shape.type === 'quartercircle') {
                    drawQuarterCircle(ctx, shape.x, shape.y, shape.radius, shape.direction);
                } else if (shape.type === 'circle') {
                    ctx.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
                } else if (shape.type === 'rectangle') {
                    ctx.rect(shape.x, shape.y, shape.width, shape.height);
                } else if (shape.type === 'square') {
                    ctx.rect(shape.x, shape.y, shape.sideLength, shape.sideLength);
                }
                if (shape.isHollow) {
                    ctx.fillStyle = 'white'; // Relleno blanco
                    ctx.fill();
                    ctx.stroke();
                } else {
                    ctx.fillStyle = 'black'; // Relleno blanco
                    ctx.fill();
                    ctx.stroke();
                }
            });
        }


        function drawSemiCircle(ctx, x, y, radius, direction) {
            let startAngle, endAngle;
            switch (direction) {
                case 'izquierda':
                    startAngle = 0.5 * Math.PI;
                    endAngle = 1.5 * Math.PI;
                    break;
                case 'derecha':
                    startAngle = 1.5 * Math.PI;
                    endAngle = 0.5 * Math.PI;
                    break;
                case 'arriba':
                    startAngle = 0;
                    endAngle = Math.PI;
                    break;
                case 'abajo':
                    startAngle = Math.PI;
                    endAngle = 2 * Math.PI;
                    break;
            }
            ctx.arc(x, y, radius, startAngle, endAngle);
        }

        function drawQuarterCircle(ctx, x, y, radius, direction) {
            let startAngle, endAngle;
            switch (direction) {
                case 'izquierda-arriba':
                    startAngle = 0;
                    endAngle = 0.5 * Math.PI;
                    break;
                case 'derecha-arriba':
                    startAngle = 0.5 * Math.PI;
                    endAngle = Math.PI;
                    break;
                case 'izquierda-abajo':
                    startAngle = 1.5 * Math.PI;
                    endAngle = 2 * Math.PI;
                    break;
                case 'derecha-abajo':
                    startAngle = Math.PI;
                    endAngle = 1.5 * Math.PI;
                    break;
            }
            ctx.arc(x, y, radius, startAngle, endAngle);
        }

        function drawSemiCircle(ctx, x, y, radius, direction) {
            let startAngle, endAngle;
            switch (direction) {
                case 'izquierda':
                    startAngle = 0.5 * Math.PI;
                    endAngle = 1.5 * Math.PI;
                    break;
                case 'derecha':
                    startAngle = 1.5 * Math.PI;
                    endAngle = 0.5 * Math.PI;
                    break;
                case 'arriba':
                    startAngle = 0;
                    endAngle = Math.PI;
                    break;
                case 'abajo':
                    startAngle = Math.PI;
                    endAngle = 0;
                    break;
            }
            ctx.beginPath();
            ctx.arc(x, y, radius, startAngle, endAngle);
            ctx.closePath(); // Cierra el contorno del semicírculo
        }
        
        
        function drawQuarterCircle(ctx, x, y, radius, direction) {
            let startAngle, endAngle;
            switch (direction) {
                case 'sup-izq':
                    startAngle = 0.5 * Math.PI;
                    endAngle = Math.PI;
                    break;
                case 'sup-der':
                    startAngle = 0;
                    endAngle = 0.5 * Math.PI;
                    break;
                case 'inf-izq':
                    startAngle = Math.PI;
                    endAngle = 1.5 * Math.PI;
                    break;
                case 'inf-der':
                    startAngle = 1.5 * Math.PI;
                    endAngle = 2 * Math.PI;
                    break;
            }
            ctx.beginPath();
            ctx.arc(x, y, radius, startAngle, endAngle);
            ctx.lineTo(x, y); // Conectar con el centro del círculo
            ctx.closePath(); // Cierra el contorno del cuarto de círculo
        }
        
        

        function drawSemiCirclePreview(ctx, x, y, radius, direction) {
            drawSemiCircle(ctx, x, y, radius, direction);
        }

        function drawQuarterCirclePreview(ctx, x, y, radius, direction) {
            drawQuarterCircle(ctx, x, y, radius, direction);
        }

        function drawRectangle(ctx, x, y, width, height) {
            ctx.rect(x, y, width, height);
        }

        function drawSquare(ctx, x, y, sideLength) {
            ctx.rect(x, y, sideLength, sideLength);
        }

        function iniciarLinea() {
            drawingMode = 'line';
        }

        function prepararSemicirculo() {
            let tempRadius = prompt('Radio:');
            if (tempRadius === null || tempRadius === "") {
                drawingMode = null;
                return;
            }
            radius = tempRadius;
            let tempDirection = prompt('Dirección (izquierda, derecha, arriba, abajo):').toLowerCase();
            if (tempDirection === null || tempDirection === "") {
                drawingMode = null;
                return;
            }
            direction = tempDirection;
            drawingMode = 'semicircle';
        }

        function prepararCuartoCirculo() {
            let tempRadius = prompt('Radio:');
            if (tempRadius === null || tempRadius === "") {
                drawingMode = null;
                return;
            }
            radius = tempRadius;
            let tempDirection = prompt('Dirección (sup-izq, sup-der, inf-izq, inf-der):').toLowerCase();
            if (tempDirection === null || tempDirection === "") {
                drawingMode = null;
                return;
            }
            direction = tempDirection;
            drawingMode = 'quartercircle';
        }

        function prepararCirculo() {
            let tempRadius = prompt('Radio:');
            if (tempRadius === null || tempRadius === "") {
                drawingMode = null;
                return;
            }
            radius = tempRadius;
            drawingMode = 'circle';
        }

        function prepararRectangulo() {
            drawingMode = 'rectangle';
        }

        function prepararCuadrado() {
            drawingMode = 'square';
        }

        function exportToJPG() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
        
            // Limpiar y establecer fondo blanco en el canvas temporal
            tempCtx.fillStyle = 'white';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        
            // Dibujar todas las figuras en el canvas temporal
            tempCtx.strokeStyle = 'black';
            tempCtx.lineWidth = ctx.lineWidth;
        
            // Dibujar formas
            shapes.forEach(shape => {
                tempCtx.beginPath();
                if (shape.type === 'semicircle') {
                    drawSemiCircle(tempCtx, shape.x, shape.y, shape.radius, shape.direction);
                } else if (shape.type === 'quartercircle') {
                    drawQuarterCircle(tempCtx, shape.x, shape.y, shape.radius, shape.direction);
                } else if (shape.type === 'circle') {
                    tempCtx.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
                } else if (shape.type === 'rectangle') {
                    tempCtx.rect(shape.x, shape.y, shape.width, shape.height);
                } else if (shape.type === 'square') {
                    tempCtx.rect(shape.x, shape.y, shape.sideLength, shape.sideLength);
                }
                if (shape.isHollow) {
                    tempCtx.fillStyle = 'white'; // Relleno negro para huecas
                    tempCtx.fill();
                    tempCtx.stroke();
                } else {
                    tempCtx.fillStyle = 'black'; // Relleno negro para formas sólidas
                    tempCtx.fill();
                    tempCtx.stroke();
                }
            });
        
            // Dibujar líneas en el canvas temporal
            drawLines(tempCtx);
        
            // Exportar como JPEG
            const dataURL = tempCanvas.toDataURL('image/jpeg');
            const link = document.createElement('a');
            link.download = 'figura.jpg';
            link.href = dataURL;
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        
        
        
        function limpiarLienzo() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            lines = [];
            shapes = [];
        }

        function undo() {
            if (lines.length > 0 || shapes.length > 0) {
                if (shapes.length > 0) {
                    shapes.pop();
                } else if (lines.length > 0) {
                    lines.pop();
                }
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawShapes(ctx);
                drawLines(ctx);
            }
        }
    </script>
</body>
</html>

